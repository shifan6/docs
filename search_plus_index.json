{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本前端规范适用于教研中台、工作台、CRM及学情数据平台，请务必仔细阅读。 powered by Gitbook文件修订时间： 2021-12-16 15:26:31 "},"specification/file.html":{"url":"specification/file.html","title":"文件目录","keywords":"","body":"文件目录 目录命名 文件夹均采用 kebab-case 命名，即字母小写，以中划线分割。有复数结构时，采用复数命名法。 // 推荐 scripts / styles / demo-styles // 不推荐 script / style / demo_scripts / demoStyles 【特殊】vue文件沿用现有习惯，采用 PascalCase 命名，即首字母大写。 // 示例 HeadSearch / PageLoading JS、CSS、SCSS、HTML、PNG 等文件命名 文件均采用 kebab-case 命名，即字母小写，以中划线分割。 // 示例 render-dom.js / sign-up.css / index.html / user-management.html / company-logo.png 命名严谨性 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。 // 杜绝完全不规范的缩写，避免望文不知义 AbstractClass“缩写”命名成 AbsClass，condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 目录结构 vue项目推荐使用以下结构： src 源码目录 |-- assets 静态资源，images, icons, styles, js等, 打包时需压缩格式化（已处理的第三方文件放在static中） |-- components 公用组件 |-- constants 常量信息，项目所有Enum, 全局常量等 |-- directives 自定义指令 |-- filters 过滤器，全局工具 |-- mock 模拟接口，临时存放 |-- router 路由，统一管理 |-- store vuex, 统一管理 |-- mixins mixins，统一管理 |-- utils 其他工具，bus.js、common.js |-- views 视图目录 | |-- base 基础视图，如 Header、Sidebar、Login等 | |-- role role模块名 | |-- |-- RoleList.vue role列表页面 | |-- |-- RoleAdd.vue role新建页面 | |-- |-- RoleUpdate.vue role更新页面 | |-- employee employee模块 powered by Gitbook文件修订时间： 2021-12-20 17:51:13 "},"specification/html-add-css.html":{"url":"specification/html-add-css.html","title":"HTML & CSS","keywords":"","body":"HTML & CSS HTML 规范（适用于 Vue Template） 语法 标签必须合法且闭合、嵌套正确 标签名和属性名、ID 需小写，用中划线做分隔符 在属性上，使用双引号，不要使用单引号 缩进 嵌套的节点应该缩进 缩进使用 2 个空格（一个 tab） 原则 尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价，任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 CSS 规范 命名 类名使用小写字母，以中划线分隔 scss 中的变量、函数、混合、placeholder采用驼峰式命名 类名的命名需遵循严谨性 选择器 如无特定要求，禁止通过 id 选择器定义样式，以免 id 变动引起页面布局错乱 避免使用标签选择器 尽量使用缩写属性 格式 省略 0 后面的单位 每个选择器及属性独占一行 缩进使用 2 个空格（一个 tab） 属性值前加上空格 每个属性声明末尾都要加分号 /**推荐**/ .button, .link { width: 100px; height: 50px; padding: 0; color: #fff; background: #00a0e9; } /**不推荐**/ .button, .link { width:100px;height:50px;padding:0px;color:#fff;background:#00a0e9; } powered by Gitbook文件修订时间： 2022-05-13 09:55:55 "},"specification/javascript.html":{"url":"specification/javascript.html","title":"JavaScript","keywords":"","body":"JavaScript 命名 方法名、参数名、成员变量、局部变量统一使用 lowerCamelCase 风格。 变量前缀为名词。 // 推荐 let maxCount = 10; let tableTitle = 'LoginTable'; // 不推荐 let setCount = 10; let getTitle = 'LoginTable'; 方法名推荐动词+名词形式。 // 推荐 showMessage(..) // 显示信息 getAge(..) // 返回 age calcSum(..) // 计算求和并返回结果 createForm(..) // 创建表单(通常会返回它) checkPermission(..) // 检查权限并返回 true/false // 不推荐 get() / save() / open() / message() 函数方法常用的动词可参考👇 get 获取 / set 设置, add 增加 / remove 删除 create 创建 / destory 移除 start 启动 / stop 停止 open 打开 / close 关闭, read 读取 / write 写入 load 载入 / save 保存, create 创建 / destroy 销毁 begin 开始 / end 结束, backup 备份 / restore 恢复 import 导入 / export 导出, split 分割 / merge 合并 inject 注入 / extract 提取, attach 附着 / detach 脱离 bind 绑定 / separate 分离, view 查看 / browse 浏览 edit 编辑 / modify 修改, select 选取 / mark 标记 copy 复制 / paste 粘贴, undo 撤销 / redo 重做 insert 插入 / delete 移除, add 加入 / append 添加 clean 清理 / clear 清除, index 索引 / sort 排序 find 查找 / search 搜索, increase 增加 / decrease 减少 play 播放 / pause 暂停, launch 启动 / run 运行 compile 编译 / execute 执行, debug 调试 / trace 跟踪 observe 观察 / listen 监听, build 构建 / publish 发布 input 输入 / output 输出, encode 编码 / decode 解码 encrypt 加密 / decrypt 解密, compress 压缩 / decompress 解压缩 pack 打包 / unpack 解包, parse 解析 / emit 生成 connect 连接 / disconnect 断开, send 发送 / receive 接收 download 下载 / upload 上传, refresh 刷新 / synchronize 同步 update 更新 / revert 复原, lock 锁定 / unlock 解锁 check out 签出 / check in 签入, submit 提交 / commit 交付 push 推 / pull 拉, expand 展开 / collapse 折叠 begin 起始 / end 结束, start 开始 / finish 完成 enter 进入 / exit 退出, abort 放弃 / quit 离开 obsolete 废弃 / depreciate 废旧, collect 收集 / aggregate 聚集 代码规范 使用 2 个空格进行缩进 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。 统一使用单引号(')，不使用双引号(\")。这在创建 HTML 字符串非常有好处。 对上下文 this 的引用只能使用 self 来命名 注释 单行注释 // 这个函数的执行条件，执行结果大概说明 dosomthing() 多行注释 /* * xxxx 描述较多的时候可以使用多行注释 * xxxx */ dosomthing(); 函数(方法)注释 /** * 格式化题目信息 * @param question 题目信息 * @param displayTypes 题目显示内容，默认全部显示 * @param analysisType 指定题目解析类型，默认显示图书解析 * @returns [] 格式化后的数组 */ formatQuestion(question, displayTypes = [1, 2, 3, 4, 5, 6, 7, 8], analysisType = 2) { ... } powered by Gitbook文件修订时间： 2021-12-23 14:28:08 "},"specification/vue.html":{"url":"specification/vue.html","title":"Vue","keywords":"","body":"Vue 官方规范 所有代码均需遵循 Vue 官方规范中的 A 类规范和 B 类规范。 约定 单文件组件的顶级标签应该总是按照 、 和 的顺序编写。 // 推荐 ... /* ... */ /* ... */ // 不推荐 /* ... */ /* ... */ ... 标签内部应该总是按照 name mixins components props data methods computed watch filters directives 钩子函数的顺序编写。 下列情况需注释： 公共组件使用说明 store 中的 state, mutation, action 等必须加注释 vue 文件中的 template 必须加注释，若文件较大添加 start end 注释 vue 文件的 methods，每个 method 必须添加注释 vue 文件的 data, 非常见单词要加注释 powered by Gitbook文件修订时间： 2021-12-15 17:13:57 "},"specification/compatibility.html":{"url":"specification/compatibility.html","title":"页面兼容","keywords":"","body":"页面兼容 需兼容分辨率1366x768~1920x1080，拖大和缩小窗口，页面布局不会发生错位。 powered by Gitbook文件修订时间： 2022-04-18 17:20:24 "},"specification/tool.html":{"url":"specification/tool.html","title":"工具","keywords":"","body":"工具 前端代码规范化的工具有以下三种： EditorConfig: 专注于统一编辑器编码风格配置 Prettier: 专注于检查并自动更正代码风格，美化代码 Eslint: 专注于 JavaScript 代码质量检查, 编码风格约束等 EditorConfig 不同的开发人员，不同的编辑器，有不同的编码风格，而 EditorConfig 就是用来协同团队开发人员之间的代码风格及样式规范化的一个工具，而 .editorconfig 正是它的默认配置文件。 中台每个项目下都有 .editorconfig ，下面是常规配置和主流编辑器中使用它的方法。 推荐配置 # 表示为最顶层的配置文件，不会再向上查找 root = true [*] # 字符集 charset=utf-8 # 换行符 end_of_line=lf # 缩进风格 indent_style=space # 缩进大小 indent_size=2 # 是否在文件的最后插入一个空行 insert_final_newline=true # 是否删除行尾的空格 trim_trailing_whitespace=true # 强制在指定的字符数之后进行强制换行 max_line_length=120 [*.md] trim_trailing_whitespace=false 更多配置详情可见官方文档。 在 WebStorm 启用 EditorConfig 打开 WebStorm > Preferences 找到 Editor > Code Style 并点击 找到 Enable EditorConfig support选项，勾选它前面的复选框即可 在 VS Code 启用 EditorConfig 在编辑器内，搜索并安装插件 EditorConfig for VS Code ，然后启用即可。 Prettier Prettier 只关注格式化，并不具有检查语法等能力。它通过解析代码并匹配自己的一套规则，来强制执行一致的代码展示格式。 它的配置文件有很多种，通常我们使用 .prettierrc 进行配置。 推荐配置 { \"singleQuote\": true, // 使用单引号 \"semi\": false, // 在语句末尾不添加分号 \"arrowParens\": \"avoid\", // 箭头函数参数尽可能避免使用圆括号包裹 \"bracketSpacing\": true, // 保留对象内侧两端的空格 \"embeddedLanguageFormatting\": \"auto\", // Prettier 自动识别并格式化嵌入引用代码 \"htmlWhitespaceSensitivity\": \"css\", // HTML 文件的空格敏感度和 css 的 display 属性保持一致 \"insertPragma\": false, // 在文件的第一个docblock注释中不插入@format pragma \"jsxBracketSameLine\": false, // 多行 JSX 的元素不和属性同行，在多行JSX元素的最后一行不追加 > \"jsxSingleQuote\": false, // JSX中不使用单引号 \"printWidth\": 120, // 打印宽度 \"proseWrap\": \"never\", // 对于 markdown 文件的段落不执行超出长度换行 \"quoteProps\": \"as-needed\", // 只对对象中需要的属性使用引号 \"requirePragma\": false, // 限制只格式化在文件顶部做了需格式化标识的文件 \"tabWidth\": 2, // 缩进所占列数 \"trailingComma\": \"none\", // 多行时不在结尾添加逗号 \"useTabs\": false, // 缩进风格不使用Tab \"vueIndentScriptAndStyle\": true // 是否对 Vue 文件中 和 标签内的代码应用缩进 } 安装 Prettier 插件 WebStorm：插件地址 VS Code：在编辑器内，搜索并安装插件 Prettier ，然后启用即可。 Eslint Eslint 的关注点是代码质量，它通过配置 .eslintrc.js 制定团队代码规范。它的目的是保证代码规范的一致性和及时发现代码问题、提前避免错误发生。 推荐配置 module.exports = { root: true, env: { es6: true, browser: true, node: true, commonjs: true, amd: true }, extends: ['plugin:vue/essential', '@vue/standard'], parserOptions: { ecmaVersion: 12, sourceType: 'module', parser: 'babel-eslint' }, plugins: ['vue', 'prettier'], // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue 'rules': { 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', } } VS Code 配置文件 settings.json 是 VS Code 的配置文件，项目下的 settings.json 可以统一团队格式化的逻辑，减少不必要的冲突。 推荐配置 { \"editor.formatOnSave\": false, \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": false }, \"javascript.format.semicolons\": \"remove\", // 让vetur使用vs自带的js格式化工具，以便在函数前面加个空格 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", // 指定 *.vue 文件的格式化工具为vetur \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, // 指定 *.js 文件的格式化工具为vscode自带 \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" }, // 默认使用prettier格式化支持的文件 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"vetur.validation.template\": false, \"vetur.format.scriptInitialIndent\": true, \"vetur.format.styleInitialIndent\": true } powered by Gitbook文件修订时间： 2021-12-22 17:26:50 "},"git/":{"url":"git/","title":"Git 规范","keywords":"","body":"Git 规范 Branch master master 为主分支，也是用于部署生产环境的分支 master 分支一般由已测试通过的开发分支和 hotfix 分支合并，不能直接提交 hotfix 线上出现紧急问题需要修复时，以 master 分支为基线，创建 hotfix 分支 修复完成后，需要合并到 master 分支和开发分支 开发分支 开发新需求时，基于 master 分支创建开发分支 分支命名：module-version，如文库 5.7 版本的开发分支就是 doc-5.7。无版本号时，可用需求内容命名 test test 为测试分支，即用于部署测试环境的分支 开发分支和 hotfix 分支的代码完成后，均需合并到此分支，并提交测试 Commit 针对现有情况，约定格式为 module-version：type description。其中 module 为模块名，version 为版本号，type为 commit 的类型，description 为对所提交代码的描述。 type 具体说明如下，当一次改动包括主要 type 与特殊 type 时，统一采用主要 type。 # 主要type add 增加新功能 remove 删除部分代码、功能 update 对已有功能进行更改或优化 fix 修复bug # 特殊type docs: 只改动了文档相关的内容 style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message # 暂不使用type test: 添加测试或者修改现有测试 perf: 提高性能的改动 ci: 与CI（持续集成服务）有关的改动 chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 powered by Gitbook文件修订时间： 2021-12-17 13:22:25 "},"common/previewImg.html":{"url":"common/previewImg.html","title":"查看大图","keywords":"","body":"v-preview-img 插件功能：预览单张/一组图片的大图 安装 npm install --save v-preview-img 使用示例 import previewImg from 'v-preview-img' export default { name: 'app', components: { previewImg }, data() { return { options: { initImageIndex: 1 }, previewImages: [ 'http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg', 'http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg' ] } }, methods: { exitPreview() { // ... } } } 使用说明 Props data 预览图片的队列 type: array default: ['http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg'] valid: val.length > 0 options 预览图片选项 type: object default: { initImageIndex: 0, // 配置初始位置，默认为0 zoom: true, // 配置缩放功能，默认开启 rotate: true, // 配置旋转功能，默认开启 drag: false, // 配置拖拽功能（图片显示不全时），默认关闭 closeOnClickMask: false // 是否点击遮罩层退出预览，默认否 } exit 退出预览后的方法 type: function default: function() {} 效果预览 powered by Gitbook文件修订时间： 2022-05-13 13:57:39 "},"common/textEllipsis.html":{"url":"common/textEllipsis.html","title":"文本省略","keywords":"","body":"text-ellipsis 组件功能：显示指定行数文字，支持展开 组件代码 展开 export default { name: \"text-ellipsis\", props: { line: { type: Number, default: 2 }, text: { type: String, default: '' }, backgroundColor: { type: String, default: '#fff' } }, data() { return { isEllipsis: true } }, methods: { // 计算文本内容是否溢出 calcEllipsisStatus() { const wrapper = this.$refs.text return wrapper && wrapper.offsetHeight { this.isEllipsis = this.calcEllipsisStatus() }) } }, computed: { textStyle() { return { '-webkit-line-clamp': this.isEllipsis ? this.line : '' } }, buttonStyle() { return { 'background-color': this.backgroundColor } }, }, watch: { text() { this.init() } }, mounted() { this.init() } } .text-ellipsis { position: relative; .text { overflow: hidden; text-overflow: clip; display: -webkit-box; -webkit-box-orient: vertical; line-height: 1.6; font-size: 14px; } .expand-button { position: absolute; right: 0; bottom: 0; padding: 4px 0px; } } 使用示例 import textEllipsis from '../../common/TextEllipsis' export default { name: 'other', components: { textEllipsis }, data() { return { text: '....' } } } 使用说明 Props line 初始化显示的最大行数，默认为2 text 原始文本内容 backgroundColor 组件所在容器的背景颜色，默认为'#fff' 效果预览 powered by Gitbook文件修订时间： 2022-05-13 13:57:29 "},"common/dateTimeRangePicker.html":{"url":"common/dateTimeRangePicker.html","title":"时间选择器","keywords":"","body":"date-time-range-picker 组件功能：基于element-ui 实现的日期和时间选择器，交互更友好 组件代码 {{ rangeSeparator }} 清空 const DEFAULTS = { date: { }, time: { start: '00:00', end: '23:45', step: '00:15', } } export default { name: \"date-time-picker\", model: { prop: 'value', event: 'change' }, props: { value: { required: true, validator(val) { return !val || val && Array.isArray(val) } }, rangeSeparator: { type: String, default: '-' }, pickerOptions: { type: Object, default() { return { } } }, placeholders: { type: Array, default() { return [] } } }, data() { return { start: [], end: [], datePickerOptions: Object.assign({}, DEFAULTS.date, this.pickerOptions.date || {}), timePickerOptions: Object.assign({}, DEFAULTS.time, this.pickerOptions.time || {}), } }, methods: { handleStartDateChange(val) { const date = new Date(val) const hours = this.start[1] ? this.start[1].split(':') : [0, 0] date.setHours(...hours) const start = new Date(date).getTime() const end = Math.max(this.value[1], start) this.$emit('change', [start, end]) }, handleStartTimeChange(val) { if (!this.start[0]) { return } const date = new Date(this.start[0]) const hours = val ? val.split(':') : [0, 0] date.setHours(...hours) const start = new Date(date).getTime() const end = Math.max(this.value[1], start) this.$emit('change', [start, end]) }, handleEndDateChange(val) { const date = new Date(val) const hours = this.end[1] ? this.end[1].split(':') : [0, 0] date.setHours(...hours) const end = new Date(date).getTime() const start = Math.min(this.value[0], end) this.$emit('change', [start, end]) }, handleEndTimeChange(val) { if (!this.end[0]) { return } const date = new Date(this.end[0]) const hours = val ? val.split(':') : [0, 0] date.setHours(...hours) const end = new Date(date).getTime() const start = Math.min(this.value[0], end) this.$emit('change', [start, end]) }, handleClear() { this.$emit('change', []) }, updateDateAndTime() { const [start, end] = this.value || [] const formatClock = this.$root.$options.filters['formatClock'] this.start = start ? [start, formatClock(start, 'minute')] : [] this.end = end ? [end, formatClock(end, 'minute')] : [] } }, watch: { value: { handler() { this.updateDateAndTime() }, deep: true, } }, mounted() { this.updateDateAndTime() } } .data-time-picker { width: 100%; display: flex; align-items: center; justify-content: flex-start; > * { margin-right: 8px; &:last-child { margin-right: 0; } } } .date { width: 100px; } .time { width: 60px; } /deep/ { .el-input__prefix { display: none; } .el-input__inner { padding-left: 10px; padding-right: 10px; } } 使用示例 import DateTimeRangePicker from '../../common/DateTimeRangePicker' export default { name: 'other', components: { DateTimeRangePicker }, data() { return { time: [] } }, methods: { handleChange() { // ... } } } 使用说明 Props value/v-model 组件绑定值 rangeSeparator 开始时间和结束时间的分隔符 pickerOptions 配置项，pickerOption.date的配置项参照el-date-picker，pickerOption.time参照el-time-select placeholders 开始日期、开始时间、结束日期、结束时间的选择框的占位内容 Events change 绑定值修改后触发 效果预览 powered by Gitbook文件修订时间： 2022-08-11 10:28:49 "},"common/lazyLoadSelect.html":{"url":"common/lazyLoadSelect.html","title":"懒加载选择器","keywords":"","body":"lazy-load-select 组件功能：基于 element-ui 的 el-select 增加懒加载机制，避免选项数据太多时渲染卡顿。 组件代码 filterText = '' \" v-el-select-loadmore=\"() => extraCount += config.step\" > import performanceUtils from '../../utils/performance' export default { name: \"lazy-load-select\", model: { prop: 'value', event: 'change' }, props: { clearable: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, filterable: { type: Boolean, default: false }, multiple: { type: Boolean, default: false }, remote: { type: Boolean, default: false }, remoteMethod: { type: Function }, reserveKeyword: { type: Boolean, default: false }, placeholder: { type: String, default: '' }, options: { type: Array, default() { return [] } }, value: { required: true, default: '' }, props: { type: Object, default() { return {} } }, }, data() { return { filterText: '', extraCount: 10, // 除已选中外，额外显示条数 selectedIds: '', config: {} } }, methods: { handleFocus(e) { this.$emit('focus', e) }, handleBlur(e) { this.$emit('blur', e) }, handleValueChange(value) { this.$emit('change', value) this.$emit('update:value', value) // 仅使用v-model }, filterMethod: performanceUtils.debounce(function(text) { this.filterText = text }, 300), // 初始化 init() { const defaultProps = { step: 5, initCount: 10, label: 'name', // 指定选项名称为选项对象的某个属性值 value: 'id', // 指定选项的值为选项对象的某个属性值 } this.config = Object.assign({}, defaultProps, this.props, this.config) this.selectedIds = Array.isArray(this.value) ? JSON.parse(JSON.stringify(this.value)) : this.value } }, directives: { \"el-select-loadmore\": (el, binding) => { const SELECTWRAP_DOM = el.querySelector(\".loadmore-select .el-select-dropdown .el-select-dropdown__wrap\") if (SELECTWRAP_DOM) { SELECTWRAP_DOM.addEventListener(\"scroll\", function() { const condition = this.scrollHeight - this.scrollTop - 2 it[label].toLowerCase().includes(filterText)) : allOptions const selectedOptions = filterOptions.filter((item) => selectedIds.includes(item[value])) const loadOptions = filterOptions.slice(0, this.extraCount) const loadOptionIds = loadOptions.map(it => it[value]) const extraOptions = selectedOptions.filter(it => !loadOptionIds.includes(it[value])) return extraOptions.concat(loadOptions) }, }, watch: { value() { this.init() } }, mounted() { this.init() } } 使用示例 import LazyLoadSelect from '../../common/LazyLoadSelect' export default { name: 'other', components: { LazyLoadSelect }, data() { return { userOptions: [ { userId: 1, userName: '用户1' }, { userId: 2, userName: '用户2' } ] } } } 使用说明 props value/v-model 组件绑定值 options 选择器的所有选项 props 属性配置，说明如下 参数 说明 类型 默认值 label 指定选项名称为选项对象的某个属性值 string 'name' value 指定选项的值为选项对象的某个属性值 string 'id' initCount 显示选项的初始个数 number 10 step 每次滑到底部时，选项的新增个数 number 5 以下属性与 el-select 组件用法一致： placeholder 、clearable 、disabled 、filterable、multiple、remote、remoteMethod 、reserveKeyword Events change 绑定值修改后触发 focus 输入框获得焦点时触发 blur 输入框失去焦点时触发 效果示例 powered by Gitbook文件修订时间： 2022-08-11 14:28:51 "},"common/animate.html":{"url":"common/animate.html","title":"缓动动画","keywords":"","body":"缓动动画 // utils/common.js /** * 缓动动画 * @param o 目标缓动元素, 必须; * @param a 需要变化的属性, 字符串, 必须, 只对能通过obj[attr]或者obj.style[attr]访问的属性有效 * @param t 目标数值, 可选, 默认值为0; * @param r 缓动速率, 可选, 默认值为5; * @param callback 回调函数, 参数为isEnding, 表示动画是否结束, 可选. */ animate(o, a, t, r, callback) { if(!(o && a)){ return ;} if(typeof callback != 'function'){ callback = function(){} }; t = t || 0; r = r || 5; o = o[a] != undefined ? o : o.style; var unit = typeof o[a] == 'string' && o[a].indexOf('px') > -1 ? 'px' : '' ; var last = 0; (function step(){ var c = parseFloat(o[a]); if (Math.abs((t - c)/r) 示例 animate(body, 'scrollTop', 0, 5, isEnding => {}) animate(element, 'width', 300, 50); animate(element, 'height'); 效果预览 powered by Gitbook文件修订时间： 2022-08-12 13:47:19 "},"common/file.html":{"url":"common/file.html","title":"文件处理","keywords":"","body":"文件处理 通过 url 获取文件的 blob // utils/file.js /** * 通过 url 获取文件的 Blob * @param url 文件地址 * @returns {Promise} */ getBlobByUrl(url) { return new Promise((resolve, reject) => { var xhr = new XMLHttpRequest() xhr.open(\"GET\", url, true) xhr.responseType = \"blob\" xhr.onload = function() { if (xhr.status === 200) { resolve(xhr.response) } else { reject() } } xhr.send() }) } 示例 getBlobByUrl('https://cn.vuejs.org/images/logo.svg').then(data => { ... }) 通过 base64 获取文件的 blob // utils/file.js /** * 通过 base 信息获取文件的Blob * @param base64 * @returns {Blob} */ getBlobByBase64(base64) { const array = base64.split(',') const type = array[0].match(/:(.*?);/)[1] const bytes = window.atob(array[1]) // 去掉url的头，并转换为byte const ab = new ArrayBuffer(bytes.length) const ia = new Uint8Array(ab) for (var i = 0; i 示例 getBlobByBase64('data:image/png;base64,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') 通过 blob 读取文件 // utils/file.js /** * 通过 blob 读取文件 * @param blob * @returns {Promise} */ readFileByBlob(blob) { return new Promise((resolve, reject) => { const reader = new FileReader() reader.onload = function () { resolve(reader) } reader.readAsDataURL(blob) }) }, 示例 readFileByBlob(file).then(reader => { ... }) 通过 url 加载图片 // utils/file.js /** * 通过 url 加载图片 * @param url 可以通过src加载出来的图片地址 * @param config * @returns {Promise} */ loadImageByUrl(url, config = {}) { return new Promise((resolve, reject) => { const { crossOrigin } = config const image = new Image() crossOrigin && (image.crossOrigin = crossOrigin) image.onload = function () { resolve(image) } image.src = url }) }, 示例 loadImageByUrl(formulaImg).then(image => { ... }) 获取图片的 base64 // utils/file.js /** * 获取图片的 base64 * @param image * @param config * @returns {string} */ getImageBase64(image, config = {}) { const { type = 'image/png', width, height } = config const canvas = document.createElement(\"canvas\") canvas.width = width canvas.height = height canvas.getContext(\"2d\").drawImage(image, 0, 0, width, height) // 将图片绘制到canvas中 return canvas.toDataURL(type, 1) // 转换图片为dataURL }, 示例 const src = getImageBase64(image, { width: image.width * 0.5, height: image.height * 0.5, }) 通过 blob 获取图片 // utils/file.js /** * 通过 blob 获取图片 * @param blob * @returns {Promise} */ getImageByBlob(blob) { return new Promise((resolve, reject) => { this.readFileByBlob(blob).then(reader => { this.loadImageByUrl(reader.result).then(image => { resolve(image) }) }) }) }, 示例 const { width, height } = await getImageByBlob(file) 将数据流转成文件 // utils/file.js /** * 下载后端返回的数据流 * @param stream 文件流 * @param fileName 默认的文件名称 */ downloadStream(stream, fileName) { if (!stream) { return } const blob = new Blob([stream], { type: 'application/octet-stream' }) // 将文件流放到blob对象里面 const url = window.URL.createObjectURL(blob) // 创建url 地址为blob对象 const a = document.createElement(\"a\") document.body.appendChild(a) a.style.display = 'none' a.href = url if (fileName) { a.download = fileName //文件名 } a.click() document.body.removeChild(a) window.URL.revokeObjectURL(url) }, 示例 getBlobByUrl('https://cn.vuejs.org/images/logo.svg').then(data => { downloadStream(data, 'logo-vue.svg') }) powered by Gitbook文件修订时间： 2022-05-13 10:25:42 "},"common/filters.html":{"url":"common/filters.html","title":"全局过滤器","keywords":"","body":"全局过滤器 以下过滤器会在 main.js 中注册，可全局使用。 // 在 Template 中使用 {{ value | formatDate }} // 在 script 中使用 export default { // ... mounted() { const formatTime = this.$root.$options.filters['formatTime'] console.log(formatTime(1639982308970)) } } 时间过滤器 // utils/filters.js /** * 时间过滤器 * @param timestamp 时间戳 * @returns {string} 格式示例：2020-09-17 */ const formatDate = function (timestamp) { if (timestamp == '' || timestamp == 'undefined' || timestamp == null || timestamp == 'null' || isNaN(timestamp)) { return '' } let date = new Date(timestamp) let year = date.getFullYear() let month = date.getMonth() + 1 > 9 ? date.getMonth() + 1 : '0' + (date.getMonth() + 1) let day = date.getDate() > 9 ? date.getDate() : '0' + date.getDate() return year + '-' + month + '-' + day } /** * 时间过滤器 * @param timestamp 时间戳 * @returns {string} 格式示例：2020-09-17 18:00:00 */ const formatTime = function (timestamp) { if (timestamp == '' || timestamp == 'undefined' || timestamp == null || timestamp == 'null' || isNaN(timestamp)) { return '' } let date = new Date(timestamp) let year = date.getFullYear() let month = date.getMonth() + 1 > 9 ? date.getMonth() + 1 : '0' + (date.getMonth() + 1) let day = date.getDate() > 9 ? date.getDate() : '0' + date.getDate() let hour = date.getHours() > 9 ? date.getHours() : '0' + date.getHours() let minute = date.getMinutes() > 9 ? date.getMinutes() : '0' + date.getMinutes() let second = date.getSeconds() > 9 ? date.getSeconds() : '0' + date.getSeconds() return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second } /** * 时间过滤器 * @param length 时长（秒） * @returns {string} 格式示例：66:55:44 */ const formatLength = function (length) { if (length == '' || length == 'undefined' || length == null || length == 'null' || isNaN(length)) { return '' } let second = parseInt(length) let minute = 0 let hour = 0 let temp = second if (second >= 60) { second = second % 60 minute = (temp - second) / 60 if (minute >= 60) { temp = minute minute = minute % 60 hour = (temp - minute) / 60 } } second = second 数字过滤器 // utils/filters.js /** * 百分比过滤器 * @param number 数字 * @returns {string} 格式示例：88.88% */ const percent = function (number) { if (!number) { number = 0 } number = Number(number * 100).toFixed(2); number += \"%\"; return number; } /** * 数字过滤器 * @param number 数字 * @param fixed 保留几位小数 * @returns {*} */ const formatNumber = function (number, fixed = 2) { if (!number || !number.toFixed) { return number } return parseFloat(number.toFixed(fixed)); } powered by Gitbook文件修订时间： 2022-05-13 10:24:58 "},"common/performance.html":{"url":"common/performance.html","title":"性能优化","keywords":"","body":"性能优化 防抖 对于短时间内连续触发的事件，防抖就是让某个时间期限内，事件处理函数只执行一次。 // utils/performance.js /** * 防抖：短时间内大量触发同一事件，只会执行一次函数 * @param fn 需要防抖的函数 * @param delay 毫秒，防抖期限值 * @returns {Function} */ debounce(fn, delay) { let timer = null return function (...args) { if (timer) { clearTimeout(timer) } timer = setTimeout(() => { fn.apply(this, args) }, delay) } }, 示例 const showTop = () => { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop 　console.log('滚动条位置：' + scrollTop) } window.onscroll = debounce(showTop, 1000) 节流 如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 // utils/performance.js /** * 节流：短时间内大量触发同一事件，那么在函数执行一次之后，指定的时间期限内不再工作 * @param fn 需要节流的函数 * @param delay 毫秒，节流期限值 * @returns {function(...[*]=)} */ throttle(fn, delay) { let last = 0 // 上次触发时间 return (...args) => { const now = Date.now() if (now - last > delay) { last = now fn.apply(this, args) } } } 示例 const showTop = () => { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop 　console.log('滚动条位置：' + scrollTop) } window.onscroll = throttle(showTop, 1000) powered by Gitbook文件修订时间： 2022-05-13 10:23:18 "},"common/check.html":{"url":"common/check.html","title":"数据检测","keywords":"","body":"各类数据检测 是否为有效的手机号 // utils/check.js /** * 是否手机号 * @param value * @returns {boolean} */ isPhone(value) { const reg = /^13[0-9]{9}$|14[0-9]{9}$|15[0-9]{9}$|166[0-9]{8}$|17[0-9]{9}$|18[0-9]{9}$|19[89][0-9]{8}$/ return reg.test(value) } 示例 isPhone(13655555555) // true 是否为有效的 url /** * 是否是url * @param value * @returns {boolean} */ isUrl(value) { const reg = /^((ht|f)tps?:)\\/\\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]$/ return reg.test(value) } 示例 isUrl('http://baidu.com') // true 是否为有效的邮件地址 /** * 是否是邮件 * @param value * @returns {boolean} */ isEmail(value) { const reg = /^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/ return reg.test(value) } 示例 isEmail('me@qq.com') // true powered by Gitbook文件修订时间： 2022-05-13 14:50:04 "},"advanced/use-chrome-performance.html":{"url":"advanced/use-chrome-performance.html","title":"如何分析页面性能","keywords":"","body":"Chrome performance 使用指南 用途 Chrome performance 可以分析页面在浏览器运行时的性能表现。 图例 区域介绍 功能按钮区。 Overview 区域。页面性能的高级汇总，其中 FPS 表示帧率、 CPU 表示CPU 占用、NET 表示网络请求。 火焰图区域。CPU 推叠追踪的可视化，左侧是主线程的各种事件名称。 数据统计区域。以图表形式汇总数据，其中 Summary 表示统计结果、Bottom-Up 表示事件时长顺序、Call Tree 表示事件调用顺序、Event log 表示时间发生的先后顺序。 记录运行时性能表现 点击 Record 按钮开始录制，按钮在面板左上角。 执行页面交互。 再次点击 Record 按钮，停止录制。 Chrome performance 处理数据后，在面板中显示性能报告。 分析报告 OverView 区域 FPS：每秒帧数。绿色竖线越高，FPS 越高。FPS 图标上的红色块表示长时间帧，很可能会出现卡顿。 CPU：CPU资源消耗情况。他代表着在这个时间段内，CPU在各种处理上所花费的时间，这里的各种颜色与 Summary 面板中的颜色是相互对应的。 NET：每条彩色横杠表示一种资源。横杠越长，检索资源花费的时间也就越长，每个横杠的浅色部分表示等待时间。 火焰图 在火焰图上有时会出现垂直的虚线。 蓝线：DOMContentLoaded 事件。 绿线：首次绘制的时间。 红线：load时间。 展开 Main，可以看到主线程的运行状况。X 轴代表着一个 event。长条越长就代表花费的时间越长。Y 轴代表调用栈（call stack）。在栈里，上面的 event 调用了下面的 event。 在事件长条的右上角处，如果出现了红色的小三角，说明这个事件需要特别注意。 双击这个带有红色小三角的事件，在 Summary 面板会看到详细信息。 结合火焰图和 Summary 区域就可以定位性能瓶颈，从而针对性地进行优化。 powered by Gitbook文件修订时间： 2021-12-16 15:21:26 "},"advanced/write-unit-test.html":{"url":"advanced/write-unit-test.html","title":"如何编写单元测试","keywords":"","body":"前端单元测试 测试框架 Jest Jest，是由Facebook开发的单元测试框架，也是Vue推荐的测试运行器之一。官方文档：Jest @vue/test-utils @vue/test-utils是vue官方推荐的vue测试工具，使用这个工具我们可以更方便地测试vue项目。官方文档：vue-test-utils 搭建基于jest的vue单元测试环境 新项目 通过Vue-cli创造模板脚手架时，启用单元测试，并且选择 Jest 作为单元测试框架。 已有项目 安装依赖 npm install jest vue-jest babel-jest jest-serializer-vue @vue/test-utils -D 添加文件 // test/unit/jest.conf.js const path = require('path') module.exports = { verbose: true, testURL:\"http://localhost/\", rootDir: path.resolve(__dirname, '../../'), moduleFileExtensions: [ 'js', 'json', 'vue' ], moduleNameMapper: { '^@/(.*)$': '/src/$1', }, transform: { '^.+\\\\.js$': '/node_modules/babel-jest', '.*\\\\.(vue)$': '/node_modules/vue-jest' }, snapshotSerializers: ['/node_modules/jest-serializer-vue'], setupFiles: ['/test/unit/setup'], mapCoverage: true, coverageDirectory: '/test/unit/coverage', collectCoverageFrom: [ 'src/**/*.{js,vue}', '!src/main.js', '!src/router/index.js', '!**/node_modules/**' ] } // test/unit/setup.js import Vue from 'vue' Vue.config.productionTip = false // test/unit/.eslintrc { \"env\": { \"jest\": true }, \"globals\": { } } 配置package.json \"scripts\": { \"unit\": \"jest --config test/unit/jest.conf.js --watchAll\", \"test\": \"npm run unit\" }, 编写一个测试文件 // test/unit/specs/HelloWorld.spec.js import { shallowMount } from '@vue/test-utils'; import HelloWorld from '@commponents/HelloWorld'; describe('', () => { test('should render correct contents', () => { const wrapper = shallowMount(HelloWorld); expect(wrapper.find('.hello h1').text()) .toEqual('Welcome to Your Vue.js App'); }); }); 启动测试 npm run unit jest 会自动扫描项目中所有以 .spec.js 结尾的测试文件，并执行测试用例。 编写要点 首先要确定好单元的范围，单元测试必须是针对独立模块的测试 编写测试案例(test case)，测试案例可以分为以下几种： 最基础的案例就是输入一个正确的参数时，能够得到正确的输出； 再升级一点的案例，就是在输入参数导致代码异常时，能够得到处理异常后的结果，而不是让代码错误的结果直接是系统异常而出现； 再再升级一点的话，可以针对极端情况和边界情况进行编写测试案例。 代码分支(branch)，代码分支最简单的理解就是代码里的 if else，不同的判断条件能够得到不同的输出结果，那么在进行测试编写的时候，不同分支的结果都要覆盖到 mock数据，单元测试执行过程中，如果遇到一些网络请求、文件I/O等副作用函数，建议使用mock模拟返回数据。最主要的是不能出现因为网络异常的情况，导致测试挂掉了，测试挂掉的情况一定要是代码程序出问题，而不是外界条件出的问题。 测试场景 测试DOM结构 vue-test-utils中mount、shallow、find、findAll方法都可以返回一个包裹器对象，包裹器会暴露很多封装、遍历和查询其内部的Vue组件实例的便捷的方法。 describe('Test for Test1 Component', () => { let wrapper, vm; beforeEach(() => { wrapper = shallow(Test1, { propsData: { messages: ['bye'] } }); }); test('is a Test1 component', () => { // 使用Vue组件选择器 expect(wrapper.is(Test1)).toBe(true); // 使用CSS选择器 expect(wrapper.is('.outer')).toBe(true); expect(wrapper.contains('p')).toBe(true) }); }); 测试Props 当测试对父组件向子组件传递数据这一行为时，我们想要测试的当我们传递给子组件一个特定的参数，子组件是否会按照我们所断言的那样变现。 describe('验证Props的各个属性', () = > { let wrapper = mount(Test1, { propsData: { messages: ['bye', 'bye', 'bye'] } }); const messages = wrapper.vm.$options.props.messages; test('messages is of type array', () = > { expect(messages.type).toBe(Array) }); test('messages is required', () = > { expect(messages.required).toBeTruthy() }); test('messages has at least length 2', () = > { expect(messages.validator && messages.validator(['a'])).toBeFalsy(); expect(messages.validator && messages.validator(['a', 'a'])).toBeTruthy(); }); wrapper.destroy() }); 测试自定义事件 组件的自定义事件要测试的点至少有以下两个： 测试事件会被正常触发 测试事件被触发后的后续行为符合预期 // TEST1 组件 // 省略一些代码 methods: { addCounter(value) { this.count = value } }, // MyButton组件 Click {{buttonValue}} {{innerCount}} // 省略一些代码 data() { return { innerCount: 0 } }, computed: {}, methods: { increment() { this.innerCount += 1; this.$emit('add', this.innerCount) } }, 要测试的是： 当MyButton组件的按钮被点击后会触发increment事件 点击事件发生后，Test1组件的addCounter函数会被触发并且结果符合预期（及数字递增） describe('Test for MyButton Component', () => { const wrapper = mount(MyButton); test('calls increment when click on button', () => { // mock自定义事件 const mockFn = jest.fn() wrapper.vm.$on('add', mockFn); // 触发按钮的点击事件 wrapper.find('button').trigger('click'); expect(mockFn).toBeCalled(); expect(mockFn).toHaveBeenCalledTimes(1) }) }); 测试计算属性 // Test2组件，实现功能是使用计算属性将输入框输入的字符翻转 输入： 输出：{{outputValue}} export default { name: 'Test2', props: { needReverse: { type: Boolean, default: false } }, data() { return { inputValue: '' } }, computed: { outputValue () { return this.needReverse ? ([...this.inputValue]).reverse().join('') : this.inputValue } }, methods: {}, components: {} } describe('Test for Test2 Component', () => { let wrapper; beforeEach(() => { wrapper = shallow(Test2); }); afterEach(() => { wrapper.destroy() }); test('returns the string in normal order if reversed property is not true', () => { wrapper.setProps({needReverse: false}); wrapper.vm.inputValue = 'ok'; expect(wrapper.vm.outputValue).toBe('ok') }); test('returns the string in normal order if reversed property is not provided', () => { wrapper.vm.inputValue = 'ok'; expect(wrapper.vm.outputValue).toBe('ok') }); test('returns the string in reversed order if reversed property is true', () => { wrapper.setProps({needReverse: true}); wrapper.vm.inputValue = 'ok'; expect(wrapper.vm.outputValue).toBe('ko') }) }); 测试监听属性 // 为Test添加侦听器 watch: { inputValue: function(newValue, oldValue) { if (newValue.trim().length > 0 && newValue !== oldValue) { this.printNewValue(newValue) } } }, methods: { printNewValue(value) { console.log(value) } }, describe('Test watch', () = > { let spy; beforeEach(() = > { wrapper = shallow(Test2); spy = jest.spyOn(console, 'log') }); afterEach(() = > { wrapper.destroy(); spy.mockClear() }); test('is called with the new value in other cases', (done) = > { wrapper.vm.inputValue = 'ok'; wrapper.vm.$nextTick(() = > { expect(spy).toBeCalled(); done() }) }); } 测试方法 单元测试的核心之一就是测试方法的行为是否符合预期，在测试时要避免一切的依赖，将所有的依赖都mock掉。 // Test3组件，输入问题后，点击按钮后，使用axios发送HTTP请求，获取答案 问题： click 答案：{{answer}} import axios from 'axios'; export default { name: 'Test3', data() { return { inputValue: 'ok?', answer: '', src: '' } }, methods: { getAnswer() { const URL = 'https://yesno.wtf/api'; return axios.get(URL).then(result => { if (result && result.data) { this.answer = result.data.answer; this.src = result.data.image； return result } }).catch(e => {}) } } } 这个例子里面，我们仅仅关注测试getAnswer方法，其他的忽略掉。为了测试这个方法，我们需要做的有： 我们不需要实际调用axios.get方法，需要将它mock掉 我们需要测试是否调用了axios方法（但是并不实际触发）并且返回了一个Promise对象 返回的Promise对象执行了回调函数，设置用户名和头像 在Test3.spec.js中，首先将axios中的get方法替换为我们的mock函数，然后引入相应的模块 const mockData = { data: { answer: 'mock_yes', image: 'mock.png' } }; jest.mock('axios', () => ({ get: jest.fn(() => Promise.resolve(mockData)) })); import { shallow } from 'vue-test-utils'; import Test3 from '@/components/Test3'; import axios from 'axios'; describe('Test for Test3 Component', () => { let wrapper; beforeEach(() => { axios.get.mockClear(); wrapper = shallow(Test3); }); afterEach(() = > { wrapper.destroy() }); // 点击按钮后调用了 getAnswer 方法 test('getAnswer Fn should be called', () => { const mockFn = jest.spyOn(wrapper.vm, 'getAnswer') wrapper.find('button').trigger('click'); expect(mockFn).toBeCalled(); }); // 点击按钮后调用了axios.get方法 test('axios.get Fn should be called', () => { const URL = 'https://yesno.wtf/api'; wrapper.find('button').trigger('click'); expect(axios.get).toBeCalledWith(URL) }); }); powered by Gitbook文件修订时间： 2021-12-16 15:23:30 "},"advanced/publish-npm-plugins.html":{"url":"advanced/publish-npm-plugins.html","title":"如何构建插件","keywords":"","body":"Vue.js - 构建插件并在NPM上发布 引言 插件在我们日常开发中必不可少，那么如何构建自己的插件呢？这篇文档以 v-preview-img 插件为例，依次介绍构建、打包、发布和使用四个环节。 构建插件 步骤 1：安装依赖 v-preview-img 插件是基于 Vue CLI 开发和打包的，所以先要安装全局依赖： $ npm install -g @vue/cli $ npm install -g @vue/cli-service-global 如果已经全局安装了旧版本的 vue-cli (1.x或2.x)，需要先卸载再安装新版本。 步骤 2：初始化插件目录 首先，我们先创建一个空项目： $ vue create project-name 执行完这个命令后会有一些提示，一直回车就可以啦，项目生成后目录结构如下： 在此基础上，我根据实际需要删掉不要的，新建了 PreviewImg.vue ，此时目录结构如下： 好了，这时候执行以下命令，就能在浏览器中访问了： $ vue serve src/PreviewImg.vue 更多关于vue快速原型开发的知识，可以查看官方文档 步骤 3：完善插件代码 模版 Template {{ currentTip }} 0\"> 退出预览 JavaScript export default { name: \"preview-img\", props: { data: { type: Array, default() { return [ 'http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg' ] }, validator(data) { return data.length > 0 } }, options: { type: Object, default() { return {} } }, exit: { type: Function, default() { console.log('退出预览') } } }, data() { return { defaultOptions: { initImageIndex: 0, }, currentImageUrl: '', currentImageIndex: '', rotate: 0, tipList: [ '不能再放大了哦', '不能再缩小了哦', '前面已经没有了', '已经是最后一张了哦' ], currentTip: '', size: { actualWidth: 0, width: 'auto', zoom: 1 } } }, methods: { // 旋转 rotateImg() { this.rotate = (this.rotate + 1) % 4 }, // 逆向旋转 rotateImgBack() { this.rotate = (this.rotate + 3) % 4 }, // 放大 largeImg() { if (this.size.zoom >= 1.5) { this.showTip(0) } else { this.size.zoom = parseFloat(this.size.zoom) + 0.1 this.size.width = this.size.zoom * this.size.actualWidth } }, // 缩小 narrowImg() { if (this.size.zoom { this.currentTip = '' }, 1500) }, // 显示图片 showImage(index) { this.currentImageIndex = index this.currentImageUrl = this.data[index] // 获取图片实际尺寸 this.getImageSize(this.currentImageUrl, this.calcShowSize) }, // 计算最佳的显示比例 calcShowSize({ width, height }) { const windowWidth = window.innerWidth const windowHeight = window.innerHeight let zoom = 1 if(width > windowWidth || height > windowHeight){ zoom = Math.min(windowWidth/width, windowHeight/height).toFixed(1) zoom = Math.max(zoom, 0.1) } this.size = { actualWidth: width, width: width*zoom, zoom: zoom } }, // 获取图片尺寸 getImageSize(url, callback) { const img = new Image() img.src = url // 判断是否有缓存 if(img.complete){ callback({ width: img.width, height: img.height }) }else{ img.onload = function(){ callback({ width: img.width, height: img.height }) } } }, }, mounted() { const options = Object.assign(this.defaultOptions, this.options) this.showImage(options.initImageIndex) } } 样式 Style .preview-wrapper { margin-top: 30px; } .preview-img { position: fixed; top: 0; right: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 22; overflow: auto; box-sizing: border-box; } .preview-img .image-wrapper { position: fixed; top: 0; width: 100%; height: 100%; z-index: 33; text-align: center; overflow-y: auto; display: flex; padding-bottom: 60px; } .preview-img .image-wrapper .mainImg { cursor: pointer; position: relative; top: 0; bottom: 0; left: 0; right: 0; margin: auto; } .preview-img .side-click { height: 100%; width: 6%; cursor: pointer; } .preview-img .side-click div { position: fixed; z-index: 44; background-color: rgba(40, 40, 40, 0.8); height: 80px; width: 60px; top: 50%; margin-top: -40px; display: flex; align-items: center; justify-content: center; } .preview-img .side-click .clickArrow { width: 50%; } .preview-img .side-click.fl div{ left: 20px; } .preview-img .side-click.fr div{ right: 20px; } .rotate0 { transform: rotate(0deg); } .rotate90 { transform: rotate(90deg); } .rotate180 { transform: rotate(180deg); } .rotate270 { transform: rotate(270deg); } .fr { float: right; } .fl { float: left; } .bottom { position: fixed; width: 100%; z-index: 55; bottom: 0; left: 0; display: flex; justify-content: center; padding: 15px 0; background-color: rgba(0, 0, 0, .4); } .bottom .rotate { height: 30px; cursor: pointer; margin: 0 10px; } .bottom .button { margin: 0 10px; cursor: pointer; padding: 5px 10px; color: #d3d5dc; font-size: 14px; border: 1px solid #d3d5dc; border-radius: 4px; } .bottom .button:hover { color: #333; background: #d3d5dc; } .tip { position: fixed; top: 100px; margin: auto; left: 0; right: 0; background-color: #888; color: #fff; height: 30px; font-size: 14px; line-height: 30px; width: 150px; text-align: center; padding: 0 5px; border-radius: 6px; z-index: 100; } 到这里，插件就构建的差不多啦，后续可以像这样使用： 打包插件 步骤 1： 完善 package.json 文件 { \"private\": false, \"name\": \"v-preview-img\", \"version\": \"1.0.9\", \"description\": \"图片预览插件\", \"main\": \"./dist/index.umd.js\", \"files\": [ \"dist\" ], \"author\": \"Shi Fan\", \"license\": \"MIT\", \"scripts\": { \"dev\": \"vue serve src/PreviewImg.vue\", \"lib\": \"vue-cli-service build --target lib --name index --dest dist src/PreviewImg.vue\" }, \"dependencies\": { \"core-js\": \"^3.6.5\", \"vue\": \"^2.6.11\" }, \"devDependencies\": { \"@vue/cli-plugin-babel\": \"~4.5.0\", \"@vue/cli-plugin-eslint\": \"~4.5.0\", \"@vue/cli-service\": \"~4.5.0\", \"babel-eslint\": \"^10.1.0\", \"eslint\": \"^6.7.2\", \"eslint-plugin-vue\": \"^6.2.2\", \"vue-template-compiler\": \"^2.6.11\" }, \"eslintConfig\": { \"root\": true, \"env\": { \"node\": true }, \"extends\": [ \"plugin:vue/essential\", \"eslint:recommended\" ], \"parserOptions\": { \"parser\": \"babel-eslint\" }, \"rules\": {} }, \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"not dead\" ] } 说明 private: 为 false 时代表包不是私有的，所有人都能查看并 npm install name: 后续发布到 npm 的包名，请确保你的包名未被注册，否则在发布时会报错 version: 版本号，在每次发布更新到 npm 时，都需要增加版本号 description: 描述信息 main: 指定入口文件，默认值是模块根目录下面的 index.js scripts: 指定一些脚本命令的 npm 命令行缩写，这里的 npm run lib 就是打包命令的缩写 files: 指定哪些文件需要被发布到 npm 上，这里就指定发布 dist 文件夹 可以在 npm 官方文档查看更多关于 package.json 的知识 步骤 2：配置静态资源 vue.config.js module.exports = { chainWebpack: config => { config.module .rule('images') .use('url-loader') .loader('url-loader') .tap(options => Object.assign(options, { limit: 20000 })) }, css: { extract: false } } 以上是指打包时将20KB以下的图片转为base64，将css强制内联（无需在使用时另外引用样式） 步骤 3：执行打包命令 $ npm run lib 打包成功后，在项目根目录下会生成一个 dist 文件夹，里面有个 index.umd.js 文件。 发布插件 完成前面两个环节，插件就完成啦，接下来可以把它发布到 npm 上了。 首先，我们使用以下指令登陆，如果还没有账号的话先去注册。 $ npm login // 回车后，输入你注册npmjs时填写的用户名，密码和邮箱 // 登录成功后，会提示：Logged in as on https://registry.npmjs.org/. 登陆成功后，开始发布： $ npm publish 后续更新插件，只需要增加package.json里的version版本号，然后再次执行 npm publish 发布更新就可以了！ 使用插件 在项目中安装插件 npm install --save v-preview-img 在组件中使用 import previewImg from 'v-preview-img' export default { name: 'app', components: { previewImg }, data() { return { options: { initImageIndex: 1 }, previewImages: [ 'http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg', 'http://git.tsingzone.com/uploads/user/avatar/49/22771955.jpeg' ] } }, methods: { exitPreview() { // ... } } } 效果预览 以上就是构建插件的流程啦，附上插件源代码。 v-preview-img 插件比较简单，实际上插件的范围没有限制，这里列出来几种以作参考： 添加全局方法或者属性 (如: vue-custom-element) 添加全局资源：指令/过滤器/过渡等 (如：vue-touch) 通过全局 mixin 方法添加一些组件选项 (如：vue-router) 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现 (如：vue-axios) 一个库，提供自己的 API，同时提供上面提到的一个或多个功能（如：vue-router） powered by Gitbook文件修订时间： 2021-12-16 15:15:45 "}}